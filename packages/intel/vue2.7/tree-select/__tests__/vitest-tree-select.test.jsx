/* eslint-disable @typescript-eslint/no-unused-vars */
/**
 * 该文件由脚本自动生成，如需修改请联系 PMC
 * This file generated by scripts of tdesign-api. `npm run api:docs TreeSelect Vue(PC) vitest,finalProject,useDefault`
 * If you need to modify this file, contact PMC first please.
 */
import { mount } from '@vue/test-utils';
import { vi } from 'vitest';
import {
  mockDelay,
  simulateInputChange,
  simulateDocumentMouseEvent,
  createElementById,
  simulateInputEnter,
} from '@test/utils';
import { TreeSelect } from '..';
import { getTreeSelectDefaultMount, getTreeSelectMultipleMount, getTreeSelectKeysMount } from './mount';

describe('TreeSelect Component', () => {
  afterEach(() => {
    document.querySelectorAll('.t-popup').forEach((node) => node?.remove());
  });

  it('props.autofocus is equal to false', () => {
    const wrapper = mount({
      render() {
        return <TreeSelect autofocus={false}></TreeSelect>;
      },
    });
    const domWrapper = wrapper.find('input');
    expect(domWrapper.attributes('autofocus')).toBeUndefined();
  });
  it('props.autofocus is equal to true', () => {
    const wrapper = mount({
      render() {
        return <TreeSelect autofocus={true}></TreeSelect>;
      },
    });
    const domWrapper = wrapper.find('input');
    expect(domWrapper.attributes('autofocus')).toBeDefined();
  });

  it('props.borderless works fine', () => {
    // borderless default value is false
    const wrapper1 = mount({
      render() {
        return <TreeSelect></TreeSelect>;
      },
    });
    expect(wrapper1.classes('t-select-input--borderless')).toBeFalsy();
    // borderless = true
    const wrapper2 = mount({
      render() {
        return <TreeSelect borderless={true}></TreeSelect>;
      },
    });
    expect(wrapper2.classes('t-select-input--borderless')).toBeTruthy();
    // borderless = false
    const wrapper3 = mount({
      render() {
        return <TreeSelect borderless={false}></TreeSelect>;
      },
    });
    expect(wrapper3.classes('t-select-input--borderless')).toBeFalsy();
  });

  it('props.clearable: empty value can not show clear icon', async () => {
    const wrapper = mount({
      render() {
        return <TreeSelect clearable={true}></TreeSelect>;
      },
    });
    wrapper.find('.t-input').trigger('mouseenter');
    await wrapper.vm.$nextTick();
    expect(wrapper.find('.t-input__suffix-clear').exists()).toBeFalsy();
  });

  it('props.clearable: show clear icon on mouse enter in single tree select', async () => {
    const wrapper = getTreeSelectDefaultMount(TreeSelect, { value: 1, clearable: true });
    wrapper.find('.t-input').trigger('mouseenter');
    await mockDelay(0);
    expect(wrapper.find('.t-input__suffix-clear').exists()).toBeTruthy();
  });

  it('props.clearable: show clear icon on mouse enter in multiple tree select', async () => {
    const wrapper = getTreeSelectMultipleMount(TreeSelect, { value: [1], clearable: true });
    wrapper.find('.t-input').trigger('mouseenter');
    await wrapper.vm.$nextTick();
    expect(wrapper.find('.t-tag-input__suffix-clear').exists()).toBeTruthy();
  });

  it('props.collapsedItems works fine', () => {
    const wrapper = getTreeSelectMultipleMount(TreeSelect, {
      collapsedItems: (h) => <span class="custom-node">TNode</span>,
      minCollapsedNum: 2,
      value: [1, 3, '5'],
      data: [
        { label: 'tdesign-vue', value: 1 },
        { label: 'tdesign-react', value: 2 },
        { label: 'tdesign-miniprogram', value: 3 },
        { label: 'tdesign-angular', value: '5' },
        { label: 'tdesign-mobile-vue', value: '6' },
      ],
    });
    expect(wrapper.find('.custom-node').exists()).toBeTruthy();
  });

  it('slots.collapsedItems works fine', () => {
    const wrapper = getTreeSelectMultipleMount(TreeSelect, {
      scopedSlots: { collapsedItems: (h) => <span class="custom-node">TNode</span> },
      minCollapsedNum: 2,
      value: [1, 3, '5'],
      data: [
        { label: 'tdesign-vue', value: 1 },
        { label: 'tdesign-react', value: 2 },
        { label: 'tdesign-miniprogram', value: 3 },
        { label: 'tdesign-angular', value: '5' },
        { label: 'tdesign-mobile-vue', value: '6' },
      ],
    });
    expect(wrapper.find('.custom-node').exists()).toBeTruthy();
  });
  it('slots.collapsed-items works fine', () => {
    const wrapper = getTreeSelectMultipleMount(TreeSelect, {
      scopedSlots: { 'collapsed-items': (h) => <span class="custom-node">TNode</span> },
      minCollapsedNum: 2,
      value: [1, 3, '5'],
      data: [
        { label: 'tdesign-vue', value: 1 },
        { label: 'tdesign-react', value: 2 },
        { label: 'tdesign-miniprogram', value: 3 },
        { label: 'tdesign-angular', value: '5' },
        { label: 'tdesign-mobile-vue', value: '6' },
      ],
    });
    expect(wrapper.find('.custom-node').exists()).toBeTruthy();
  });

  it('props.collapsedItems is a function with params', () => {
    const fn = vi.fn();
    getTreeSelectMultipleMount(TreeSelect, {
      collapsedItems: fn,
      minCollapsedNum: 2,
      value: [1, 3, '5'],
      data: [
        { label: 'tdesign-vue', value: 1 },
        { label: 'tdesign-react', value: 2 },
        { label: 'tdesign-miniprogram', value: 3 },
        { label: 'tdesign-angular', value: '5' },
        { label: 'tdesign-mobile-vue', value: '6' },
      ],
    });
    expect(fn).toHaveBeenCalled();
    expect(fn.mock.calls[0][1].count).toBe(1);
    expect(fn.mock.calls[0][1].value).toEqual([
      { label: 'tdesign-vue', value: 1 },
      { label: 'tdesign-miniprogram', value: 3 },
      { label: 'tdesign-angular', value: '5' },
    ]);
    expect(fn.mock.calls[0][1].collapsedSelectedItems).toEqual([{ label: 'tdesign-angular', value: '5' }]);
  });
  it('slots.collapsedItems: a function with params', () => {
    const fn = vi.fn();
    getTreeSelectMultipleMount(TreeSelect, {
      scopedSlots: { collapsedItems: fn },
      minCollapsedNum: 2,
      value: [1, 3, '5'],
      data: [
        { label: 'tdesign-vue', value: 1 },
        { label: 'tdesign-react', value: 2 },
        { label: 'tdesign-miniprogram', value: 3 },
        { label: 'tdesign-angular', value: '5' },
        { label: 'tdesign-mobile-vue', value: '6' },
      ],
    });

    expect(fn).toHaveBeenCalled();
    expect(fn.mock.calls[0][0].count).toBe(1);
    expect(fn.mock.calls[0][0].value).toEqual([
      { label: 'tdesign-vue', value: 1 },
      { label: 'tdesign-miniprogram', value: 3 },
      { label: 'tdesign-angular', value: '5' },
    ]);
    expect(fn.mock.calls[0][0].collapsedSelectedItems).toEqual([{ label: 'tdesign-angular', value: '5' }]);
  });

  it('props.data: empty data with panel content node', async () => {
    const wrapper = mount({
      render() {
        return <TreeSelect data={[]}></TreeSelect>;
      },
    });
    wrapper.find('.t-input').trigger('click');
    await wrapper.vm.$nextTick();
    const tSelectEmptyDom = document.querySelector('.t-select__empty');
    expect(tSelectEmptyDom).toBeTruthy();
  });

  it('props.disabled works fine', () => {
    // disabled default value is
    const wrapper1 = mount({
      render() {
        return <TreeSelect></TreeSelect>;
      },
    }).find('.t-input');
    expect(wrapper1.classes('t-is-disabled')).toBeFalsy();
    // disabled = true
    const wrapper2 = mount({
      render() {
        return <TreeSelect disabled={true}></TreeSelect>;
      },
    }).find('.t-input');
    expect(wrapper2.classes('t-is-disabled')).toBeTruthy();
    // disabled = false
    const wrapper3 = mount({
      render() {
        return <TreeSelect disabled={false}></TreeSelect>;
      },
    }).find('.t-input');
    expect(wrapper3.classes('t-is-disabled')).toBeFalsy();
  });

  it('props.disabled: disabled TreeSelect can not open popup', async () => {
    const onPopupVisibleChangeFn = vi.fn();
    const wrapper = mount({
      render() {
        return <TreeSelect disabled={true} on={{ 'popup-visible-change': onPopupVisibleChangeFn }}></TreeSelect>;
      },
    });
    wrapper.find('.t-input').trigger('click');
    await wrapper.vm.$nextTick();
    expect(onPopupVisibleChangeFn).not.toHaveBeenCalled();
  });

  it('props.disabled: cant not show clear icon on mouse enter in single tree select', async () => {
    const wrapper = getTreeSelectDefaultMount(TreeSelect, { value: 1, disabled: true });
    wrapper.find('.t-input').trigger('mouseenter');
    await mockDelay(0);
    expect(wrapper.find('.t-input__suffix-clear').exists()).toBeFalsy();
  });

  it('props.disabled: cant not show clear icon on mouse enter in multiple tree select', async () => {
    const wrapper = getTreeSelectMultipleMount(TreeSelect, { value: [1], disabled: true });
    wrapper.find('.t-input').trigger('mouseenter');
    await wrapper.vm.$nextTick();
    expect(wrapper.find('.t-tag-input__suffix-clear').exists()).toBeFalsy();
  });

  it('props.empty works fine', async () => {
    const wrapper = mount({
      render() {
        return <TreeSelect empty={(h) => <span class="custom-node">TNode</span>}></TreeSelect>;
      },
    });
    wrapper.find('.t-input').trigger('click');
    await wrapper.vm.$nextTick();
    const customNodeDom = document.querySelector('.custom-node');
    expect(customNodeDom).toBeTruthy();
  });

  it('slots.empty works fine', async () => {
    const wrapper = mount({
      render() {
        return <TreeSelect scopedSlots={{ empty: (h) => <span class="custom-node">TNode</span> }}></TreeSelect>;
      },
    });
    wrapper.find('.t-input').trigger('click');
    await wrapper.vm.$nextTick();
    const customNodeDom = document.querySelector('.custom-node');
    expect(customNodeDom).toBeTruthy();
  });

  it('props.filter: multiple tree select & filterable', async () => {
    const wrapper = getTreeSelectMultipleMount(TreeSelect, {
      filter: (filterWord, node) => !filterWord || node.data.label === filterWord,
    });
    wrapper.find('.t-input').trigger('click');
    await wrapper.vm.$nextTick();
    const inputDom1 = wrapper.find('input').element;
    simulateInputChange(inputDom1, 'tdesign-react');
    await mockDelay(100);
    const tTreeItemNotTTreeItemHiddenDom = document.querySelectorAll('.t-tree__item:not(.t-tree__item--hidden)');
    expect(tTreeItemNotTTreeItemHiddenDom.length).toBe(1);
    document.querySelectorAll('.t-popup').forEach((node) => node.remove());
  });

  it('props.filter: priority of onSearch is higher than props.filter, props.filter is forbidden to work in this scene', async () => {
    const wrapper = getTreeSelectMultipleMount(TreeSelect, {
      onSearch: () => {},
      filter: (filterWord, option) => !filterWord || option.label === filterWord,
    });
    wrapper.find('.t-input').trigger('click');
    await wrapper.vm.$nextTick();
    const inputDom1 = wrapper.find('input').element;
    simulateInputChange(inputDom1, 'tdesign-react');
    await mockDelay(100);
    const tTreeItemNotTTreeItemHiddenDom = document.querySelectorAll('.t-tree__item:not(.t-tree__item--hidden)');
    expect(tTreeItemNotTTreeItemHiddenDom.length).toBe(6);
    document.querySelectorAll('.t-popup').forEach((node) => node.remove());
  });

  it('props.filter: multiple tree select, check filter nodes', async () => {
    const wrapper = getTreeSelectMultipleMount(TreeSelect, { filterable: true });
    wrapper.find('.t-input').trigger('click');
    await wrapper.vm.$nextTick();
    const inputDom1 = wrapper.find('input').element;
    simulateInputChange(inputDom1, 'tdesign-vue');
    await mockDelay(100);
    document.querySelector('.t-tree__item:first-child').click();
    await wrapper.vm.$nextTick();
    document.querySelectorAll('.t-popup').forEach((node) => node.remove());
  });

  it('props.filter: single tree select, check filter nodes', async () => {
    const onChangeFn2 = vi.fn();
    const wrapper = getTreeSelectDefaultMount(TreeSelect, { filterable: true }, { change: onChangeFn2 });
    wrapper.find('.t-input').trigger('click');
    await wrapper.vm.$nextTick();
    const inputDom1 = wrapper.find('input').element;
    simulateInputChange(inputDom1, 'tdesign-vue');
    await mockDelay(100);
    document.querySelector('.t-tree__item:first-child').click();
    await wrapper.vm.$nextTick();
    document.querySelectorAll('.t-popup').forEach((node) => node.remove());
    expect(onChangeFn2).toHaveBeenCalled();
    expect(onChangeFn2.mock.calls[0][0]).toBe(1);
    expect(onChangeFn2.mock.calls[0][1].node).toBeTruthy();
    expect(onChangeFn2.mock.calls[0][1].data).toEqual({ label: 'tdesign-vue', value: 1 });
    expect(onChangeFn2.mock.calls[0][1].trigger).toBe('check');
    expect(onChangeFn2.mock.calls[0][1].e.type).toBe('click');
  });

  it('props.filterable works fine', async () => {
    const wrapper = getTreeSelectDefaultMount(TreeSelect, { inputValue: 'tdesign-vue', filterable: true });
    wrapper.find('.t-input').trigger('click');
    await mockDelay(100);
    const tTreeItemNotTTreeItemHiddenDom = document.querySelectorAll('.t-tree__item:not(.t-tree__item--hidden)');
    expect(tTreeItemNotTTreeItemHiddenDom.length).toBe(1);
    document.querySelectorAll('.t-popup').forEach((node) => node.remove());
  });

  it("props.inputProps is equal to {name:'tree-select-input-name'}", () => {
    const wrapper = mount({
      render() {
        return <TreeSelect inputProps={{ name: 'tree-select-input-name' }}></TreeSelect>;
      },
    });
    const domWrapper = wrapper.find('input');
    expect(domWrapper.attributes('name')).toBe('tree-select-input-name');
  });

  it('props.inputValue: uncontrolled inputValue works fine', async () => {
    const onInputChangeFn1 = vi.fn();
    const wrapper = getTreeSelectMultipleMount(TreeSelect, { filterable: true }, { 'input-change': onInputChangeFn1 });
    wrapper.find('.t-input').trigger('click');
    await wrapper.vm.$nextTick();
    const inputDom1 = wrapper.find('input').element;
    simulateInputChange(inputDom1, 'tdesign');
    await wrapper.vm.$nextTick();
    const attrDom1 = wrapper.find('input');
    expect(attrDom1.element.value).toBe('tdesign');
    expect(onInputChangeFn1).toHaveBeenCalled();
    expect(onInputChangeFn1.mock.calls[0][0]).toBe('tdesign');
    expect(onInputChangeFn1.mock.calls[0][1].e.type).toBe('input');
    expect(onInputChangeFn1.mock.calls[0][1].trigger).toBe('input');
  });

  it('props.inputValue: controlled inputValue works fine', async () => {
    const onInputChangeFn = vi.fn();
    const wrapper = getTreeSelectMultipleMount(
      TreeSelect,
      { filterable: true, inputValue: 'tdesign', popupVisible: true },
      { 'input-change': onInputChangeFn },
    );
    const inputDom = wrapper.find('input').element;
    simulateInputChange(inputDom, 'Hello TDesign');
    await wrapper.vm.$nextTick();
    const attrDom = wrapper.find('input');
    expect(attrDom.element.value).toBe('tdesign');
    document.querySelectorAll('.t-popup').forEach((node) => node.remove());
    expect(onInputChangeFn).toHaveBeenCalled();
    expect(onInputChangeFn.mock.calls[0][0]).toBe('Hello TDesign');
    expect(onInputChangeFn.mock.calls[0][1].e.type).toBe('input');
    expect(onInputChangeFn.mock.calls[0][1].trigger).toBe('input');
  });

  it('props.keys: single tree select, keys works fined', async () => {
    getTreeSelectKeysMount(TreeSelect, {
      keys: { label: 'name', value: 'key' },
      popupVisible: true,
      treeProps: { expandAll: true },
      popupProps: { overlayClassName: 'singleTreeSelectKeys' },
    });
    await mockDelay(200);
    const singleTreeSelectKeysTTreeItemDom = document.querySelector('.singleTreeSelectKeys .t-tree__item');
    expect(singleTreeSelectKeysTTreeItemDom.textContent).toBe('tdesign-vue');
    const singleTreeSelectKeysTTreeItemNthChild2Dom = document.querySelector(
      '.singleTreeSelectKeys .t-tree__item:nth-child(2)',
    );
    expect(singleTreeSelectKeysTTreeItemNthChild2Dom.textContent).toBe('tdesign-react');
    const singleTreeSelectKeysTTreeItemNthChild3Dom = document.querySelector(
      '.singleTreeSelectKeys .t-tree__item:nth-child(3)',
    );
    expect(singleTreeSelectKeysTTreeItemNthChild3Dom.textContent).toBe('tdesign-web-react');
    const singleTreeSelectKeysTTreeItemLastChildDom = document.querySelector(
      '.singleTreeSelectKeys .t-tree__item:last-child',
    );
    expect(singleTreeSelectKeysTTreeItemLastChildDom.textContent).toBe('tdesign-miniprogram');
  });

  it('props.keys: multiple tree select, keys works fined', async () => {
    getTreeSelectKeysMount(TreeSelect, {
      multiple: true,
      popupVisible: true,
      keys: { label: 'name', value: 'key' },
      treeProps: { expandAll: true },
      popupProps: { overlayClassName: 'multipleTreeSelectKeys' },
    });
    await mockDelay(200);
    const multipleTreeSelectKeysTTreeItemDom = document.querySelector('.multipleTreeSelectKeys .t-tree__item');
    expect(multipleTreeSelectKeysTTreeItemDom.textContent).toBe('tdesign-vue');
    const multipleTreeSelectKeysTTreeItemNthChild2Dom = document.querySelector(
      '.multipleTreeSelectKeys .t-tree__item:nth-child(2)',
    );
    expect(multipleTreeSelectKeysTTreeItemNthChild2Dom.textContent).toBe('tdesign-react');
    const multipleTreeSelectKeysTTreeItemNthChild3Dom = document.querySelector(
      '.multipleTreeSelectKeys .t-tree__item:nth-child(3)',
    );
    expect(multipleTreeSelectKeysTTreeItemNthChild3Dom.textContent).toBe('tdesign-web-react');
    const multipleTreeSelectKeysTTreeItemLastChildDom = document.querySelector(
      '.multipleTreeSelectKeys .t-tree__item:last-child',
    );
    expect(multipleTreeSelectKeysTTreeItemLastChildDom.textContent).toBe('tdesign-miniprogram');
  });

  it('props.keys: single tree select, change event works fine', async () => {
    const onChangeFn = vi.fn();
    const wrapper = getTreeSelectKeysMount(
      TreeSelect,
      {
        value: 1,
        popupVisible: true,
        treeProps: { expandAll: true, keys: { label: 'name', value: 'key' } },
        popupProps: { overlayClassName: 'keysPropsSingle' },
      },
      { change: onChangeFn },
    );
    await mockDelay(200);
    document.querySelector('.keysPropsSingle .t-tree__item:last-child').click();
    await wrapper.vm.$nextTick();
    expect(onChangeFn).toHaveBeenCalled();
    expect(onChangeFn.mock.calls[0][0]).toBe(3);
  });

  it('props.keys: multiple tree select, change event works fine', async () => {
    const onChangeFn = vi.fn();
    const wrapper = getTreeSelectKeysMount(
      TreeSelect,
      {
        value: [1],
        multiple: true,
        popupVisible: true,
        treeProps: { expandAll: true, keys: { label: 'name', value: 'key' } },
        popupProps: { overlayClassName: 'keysPropsMultiple' },
      },
      { change: onChangeFn },
    );
    await mockDelay(200);
    document.querySelector('.keysPropsMultiple .t-tree__item:last-child .t-checkbox__label').click();
    await wrapper.vm.$nextTick();
    expect(onChangeFn).toHaveBeenCalled();
    expect(onChangeFn.mock.calls[0][0]).toEqual([1, 3]);
  });

  it('props.loading: TreeSelect contains element `.t-loading`', () => {
    // loading default value is false
    const wrapper = mount({
      render() {
        return <TreeSelect></TreeSelect>;
      },
    });
    expect(wrapper.find('.t-loading').exists()).toBeFalsy();
    // loading = false
    const wrapper1 = mount({
      render() {
        return <TreeSelect loading={false}></TreeSelect>;
      },
    });
    expect(wrapper1.find('.t-loading').exists()).toBeFalsy();
    // loading = true
    const wrapper2 = mount({
      render() {
        return <TreeSelect loading={true}></TreeSelect>;
      },
    });
    expect(wrapper2.find('.t-loading').exists()).toBeTruthy();
  });

  it('props.loadingText works fine', async () => {
    const wrapper = mount({
      render() {
        return <TreeSelect loadingText={(h) => <span class="custom-node">TNode</span>} loading={true}></TreeSelect>;
      },
    });
    wrapper.find('.t-input').trigger('click');
    await wrapper.vm.$nextTick();
    const customNodeDom = document.querySelector('.custom-node');
    expect(customNodeDom).toBeTruthy();
    const tSelectLoadingTipsDom = document.querySelector('.t-select__loading-tips');
    expect(tSelectLoadingTipsDom).toBeTruthy();
  });

  it('slots.loadingText works fine', async () => {
    const wrapper = mount({
      render() {
        return (
          <TreeSelect
            scopedSlots={{ loadingText: (h) => <span class="custom-node">TNode</span> }}
            loading={true}
          ></TreeSelect>
        );
      },
    });
    wrapper.find('.t-input').trigger('click');
    await wrapper.vm.$nextTick();
    const customNodeDom = document.querySelector('.custom-node');
    expect(customNodeDom).toBeTruthy();
    const tSelectLoadingTipsDom = document.querySelector('.t-select__loading-tips');
    expect(tSelectLoadingTipsDom).toBeTruthy();
  });
  it('slots.loading-text works fine', async () => {
    const wrapper = mount({
      render() {
        return (
          <TreeSelect
            scopedSlots={{ 'loading-text': (h) => <span class="custom-node">TNode</span> }}
            loading={true}
          ></TreeSelect>
        );
      },
    });
    wrapper.find('.t-input').trigger('click');
    await wrapper.vm.$nextTick();
    const customNodeDom = document.querySelector('.custom-node');
    expect(customNodeDom).toBeTruthy();
    const tSelectLoadingTipsDom = document.querySelector('.t-select__loading-tips');
    expect(tSelectLoadingTipsDom).toBeTruthy();
  });

  it('props.loadingText: loading status show loading text in panel', async () => {
    const wrapper = mount({
      render() {
        return <TreeSelect loading={true}></TreeSelect>;
      },
    });
    wrapper.find('.t-input').trigger('click');
    await wrapper.vm.$nextTick();
    const tSelectLoadingTipsDom = document.querySelector('.t-select__loading-tips');
    expect(tSelectLoadingTipsDom).toBeTruthy();
  });

  it('props.max works fine', async () => {
    const onChangeFn1 = vi.fn();
    const wrapper = getTreeSelectMultipleMount(TreeSelect, { max: 2, value: [1, '4'] }, { change: onChangeFn1 });
    wrapper.find('.t-input').trigger('click');
    await mockDelay(300);
    document.querySelector('.t-popup .t-tree__item:last-child .t-checkbox__label').click();
    await wrapper.vm.$nextTick();
    document.querySelectorAll('.t-popup').forEach((node) => node.remove());
    expect(onChangeFn1).not.toHaveBeenCalled();
  });

  it('props.minCollapsedNum works fine. `{".t-tag":3,".t-tag:last-child":{"text":"+3"}}` should exist', () => {
    const wrapper = getTreeSelectMultipleMount(TreeSelect, { minCollapsedNum: 2 });
    expect(wrapper.findAll('.t-tag').length).toBe(3);
    expect(wrapper.find('.t-tag:last-child').text()).toBe('+3');
  });

  it('props.placeholder works fine', () => {
    const wrapper = mount({
      render() {
        return <TreeSelect placeholder={'this is tree select placeholder'}></TreeSelect>;
      },
    }).find('input');
    expect(wrapper.attributes('placeholder')).toBe('this is tree select placeholder');
  });

  it('props.popupProps works fine', async () => {
    const wrapper = mount({
      render() {
        return <TreeSelect popupProps={{ overlayClassName: 'custom-popup-class-name' }}></TreeSelect>;
      },
    });
    wrapper.find('.t-input').trigger('click');
    await wrapper.vm.$nextTick();
    const domWrapper = document.querySelector('.t-popup');
    expect(domWrapper.classList.contains('custom-popup-class-name')).toBeTruthy();
    document.querySelectorAll('.t-popup').forEach((node) => node.remove());
  });

  it('props.popupVisible works fine', () => {
    // popupVisible default value is undefined
    const wrapper1 = mount({
      render() {
        return <TreeSelect></TreeSelect>;
      },
    });
    expect(wrapper1.classes('t-select-input--popup-visible')).toBeFalsy();
    // popupVisible = true
    const wrapper2 = mount({
      render() {
        return <TreeSelect popupVisible={true}></TreeSelect>;
      },
    });
    expect(wrapper2.classes('t-select-input--popup-visible')).toBeTruthy();
    // popupVisible = false
    const wrapper3 = mount({
      render() {
        return <TreeSelect popupVisible={false}></TreeSelect>;
      },
    });
    expect(wrapper3.classes('t-select-input--popup-visible')).toBeFalsy();
  });

  it('props.prefixIcon works fine', () => {
    const wrapper = mount({
      render() {
        return <TreeSelect prefixIcon={(h) => <span class="custom-node">TNode</span>}></TreeSelect>;
      },
    });
    expect(wrapper.find('.custom-node').exists()).toBeTruthy();
  });

  it('slots.prefixIcon works fine', () => {
    const wrapper = mount({
      render() {
        return <TreeSelect scopedSlots={{ prefixIcon: (h) => <span class="custom-node">TNode</span> }}></TreeSelect>;
      },
    });
    expect(wrapper.find('.custom-node').exists()).toBeTruthy();
  });
  it('slots.prefix-icon works fine', () => {
    const wrapper = mount({
      render() {
        return <TreeSelect scopedSlots={{ 'prefix-icon': (h) => <span class="custom-node">TNode</span> }}></TreeSelect>;
      },
    });
    expect(wrapper.find('.custom-node').exists()).toBeTruthy();
  });

  it('props.readonly works fine', async () => {
    const onPopupVisibleChangeFn = vi.fn();
    const wrapper = mount({
      render() {
        return <TreeSelect readonly={true} on={{ 'popup-visible-change': onPopupVisibleChangeFn }}></TreeSelect>;
      },
    });
    wrapper.find('.t-input').trigger('click');
    await wrapper.vm.$nextTick();
    expect(onPopupVisibleChangeFn).not.toHaveBeenCalled();
  });

  const sizeClassNameList = ['t-size-s', { 't-size-m': false }, 't-size-l'];
  ['small', 'medium', 'large'].forEach((item, index) => {
    it(`props.size is equal to ${item}`, () => {
      const wrapper = mount({
        render() {
          return <TreeSelect size={item}></TreeSelect>;
        },
      }).find('.t-input');
      if (typeof sizeClassNameList[index] === 'string') {
        expect(wrapper.classes(sizeClassNameList[index])).toBeTruthy();
      } else if (typeof sizeClassNameList[index] === 'object') {
        const classNameKey = Object.keys(sizeClassNameList[index])[0];
        expect(wrapper.classes(classNameKey)).toBeFalsy();
      }
    });
  });

  const statusClassNameList = [{ 't-is-default': false }, 't-is-success', 't-is-warning', 't-is-error'];
  ['default', 'success', 'warning', 'error'].forEach((item, index) => {
    it(`props.status is equal to ${item}`, () => {
      const wrapper = mount({
        render() {
          return <TreeSelect status={item}></TreeSelect>;
        },
      }).find('.t-input');
      if (typeof statusClassNameList[index] === 'string') {
        expect(wrapper.classes(statusClassNameList[index])).toBeTruthy();
      } else if (typeof statusClassNameList[index] === 'object') {
        const classNameKey = Object.keys(statusClassNameList[index])[0];
        expect(wrapper.classes(classNameKey)).toBeFalsy();
      }
    });
  });

  it('props.tagProps is equal { theme: warning }', () => {
    const wrapper = getTreeSelectMultipleMount(TreeSelect, { tagProps: { theme: 'warning' } });
    expect(wrapper.findAll('.t-tag--warning').length).toBe(5);
  });

  it('props.tips is equal this is a tip', () => {
    const wrapper = mount({
      render() {
        return <TreeSelect tips={'this is a tip'}></TreeSelect>;
      },
    });
    expect(wrapper.findAll('.t-input__tips').length).toBe(1);
  });

  it('props.treeProps: single tree select, treeProps.keys works fined', async () => {
    getTreeSelectKeysMount(TreeSelect, {
      popupVisible: true,
      treeProps: { expandAll: true, keys: { label: 'name', value: 'key' } },
      popupProps: { overlayClassName: 'singleTreeSelectKeys' },
    });
    await mockDelay(200);
    const singleTreeSelectKeysTTreeItemDom = document.querySelector('.singleTreeSelectKeys .t-tree__item');
    expect(singleTreeSelectKeysTTreeItemDom.textContent).toBe('tdesign-vue');
    const singleTreeSelectKeysTTreeItemNthChild2Dom = document.querySelector(
      '.singleTreeSelectKeys .t-tree__item:nth-child(2)',
    );
    expect(singleTreeSelectKeysTTreeItemNthChild2Dom.textContent).toBe('tdesign-react');
    const singleTreeSelectKeysTTreeItemNthChild3Dom = document.querySelector(
      '.singleTreeSelectKeys .t-tree__item:nth-child(3)',
    );
    expect(singleTreeSelectKeysTTreeItemNthChild3Dom.textContent).toBe('tdesign-web-react');
    const singleTreeSelectKeysTTreeItemLastChildDom = document.querySelector(
      '.singleTreeSelectKeys .t-tree__item:last-child',
    );
    expect(singleTreeSelectKeysTTreeItemLastChildDom.textContent).toBe('tdesign-miniprogram');
  });

  it('props.treeProps: multiple tree select, treeProps.keys works fined', async () => {
    getTreeSelectKeysMount(TreeSelect, {
      multiple: true,
      popupVisible: true,
      treeProps: { expandAll: true, keys: { label: 'name', value: 'key' } },
      popupProps: { overlayClassName: 'multipleTreeSelectKeys' },
    });
    await mockDelay(200);
    const multipleTreeSelectKeysTTreeItemDom = document.querySelector('.multipleTreeSelectKeys .t-tree__item');
    expect(multipleTreeSelectKeysTTreeItemDom.textContent).toBe('tdesign-vue');
    const multipleTreeSelectKeysTTreeItemNthChild2Dom = document.querySelector(
      '.multipleTreeSelectKeys .t-tree__item:nth-child(2)',
    );
    expect(multipleTreeSelectKeysTTreeItemNthChild2Dom.textContent).toBe('tdesign-react');
    const multipleTreeSelectKeysTTreeItemNthChild3Dom = document.querySelector(
      '.multipleTreeSelectKeys .t-tree__item:nth-child(3)',
    );
    expect(multipleTreeSelectKeysTTreeItemNthChild3Dom.textContent).toBe('tdesign-web-react');
    const multipleTreeSelectKeysTTreeItemLastChildDom = document.querySelector(
      '.multipleTreeSelectKeys .t-tree__item:last-child',
    );
    expect(multipleTreeSelectKeysTTreeItemLastChildDom.textContent).toBe('tdesign-miniprogram');
  });

  it('props.treeProps: single tree select, trigger change event to check treeProps.keys', async () => {
    const onChangeFn = vi.fn();
    const wrapper = getTreeSelectKeysMount(
      TreeSelect,
      {
        value: 1,
        popupVisible: true,
        treeProps: { expandAll: true, keys: { label: 'name', value: 'key' } },
        popupProps: { overlayClassName: 'treePropsKeysSingle' },
      },
      { change: onChangeFn },
    );
    await mockDelay(200);
    document.querySelector('.treePropsKeysSingle .t-tree__item:last-child').click();
    await wrapper.vm.$nextTick();
    expect(onChangeFn).toHaveBeenCalled();
    expect(onChangeFn.mock.calls[0][0]).toBe(3);
  });

  it('props.treeProps: multiple tree select, trigger change event to check treeProps.keys', async () => {
    const onChangeFn = vi.fn();
    const wrapper = getTreeSelectKeysMount(
      TreeSelect,
      {
        value: [1],
        popupVisible: true,
        multiple: true,
        treeProps: { expandAll: true, keys: { label: 'name', value: 'key' } },
        popupProps: { overlayClassName: 'treePropsKeysMultiple' },
      },
      { change: onChangeFn },
    );
    await mockDelay(200);
    document.querySelector('.treePropsKeysMultiple .t-tree__item:last-child .t-checkbox__label').click();
    await wrapper.vm.$nextTick();
    expect(onChangeFn).toHaveBeenCalled();
    expect(onChangeFn.mock.calls[0][0]).toEqual([1, 3]);
  });

  it('props.value is equal to tdesign-vue', () => {
    const wrapper = mount({
      render() {
        return <TreeSelect value={'tdesign-vue'}></TreeSelect>;
      },
    });
    const domWrapper = wrapper.find('input');
    expect(domWrapper.element.value).toBe('tdesign-vue');
  });

  it('props.valueDisplay works fine', () => {
    const wrapper = getTreeSelectMultipleMount(TreeSelect, {
      valueDisplay: (h) => <span class="custom-node">TNode</span>,
      value: 1,
      data: [{ label: 'tdesign-vue', value: 1 }],
    });
    expect(wrapper.find('.custom-node').exists()).toBeTruthy();
  });

  it('slots.valueDisplay works fine', () => {
    const wrapper = getTreeSelectMultipleMount(TreeSelect, {
      scopedSlots: { valueDisplay: (h) => <span class="custom-node">TNode</span> },
      value: 1,
      data: [{ label: 'tdesign-vue', value: 1 }],
    });
    expect(wrapper.find('.custom-node').exists()).toBeTruthy();
  });
  it('slots.value-display works fine', () => {
    const wrapper = getTreeSelectMultipleMount(TreeSelect, {
      scopedSlots: { 'value-display': (h) => <span class="custom-node">TNode</span> },
      value: 1,
      data: [{ label: 'tdesign-vue', value: 1 }],
    });
    expect(wrapper.find('.custom-node').exists()).toBeTruthy();
  });

  it('props.valueDisplay is a function with params', () => {
    const fn = vi.fn();
    getTreeSelectMultipleMount(TreeSelect, { valueDisplay: fn, value: 1, data: [{ label: 'tdesign-vue', value: 1 }] });
    expect(fn).toHaveBeenCalled();
    expect(fn.mock.calls[0][1].value).toEqual([{ label: 'tdesign-vue', value: 1 }]);
    expect(fn.mock.calls[0][1].onClose).toBeTruthy();
  });
  it('slots.valueDisplay: a function with params', () => {
    const fn = vi.fn();
    getTreeSelectMultipleMount(TreeSelect, {
      scopedSlots: { valueDisplay: fn },
      value: 1,
      data: [{ label: 'tdesign-vue', value: 1 }],
    });

    expect(fn).toHaveBeenCalled();
    expect(fn.mock.calls[0][0].value).toEqual([{ label: 'tdesign-vue', value: 1 }]);
    expect(fn.mock.calls[0][0].onClose).toBeTruthy();
  });

  it('props.valueType is equal object', () => {
    const wrapper = getTreeSelectDefaultMount(TreeSelect, {
      valueType: 'object',
      multiple: true,
      value: [{ label: 'tdesign-vue', value: 1 }],
    });
    expect(wrapper.findAll('.t-tag').length).toBe(1);
  });

  it('events.blur: single select blur works fine', async () => {
    const onFocusFn = vi.fn();
    const onBlurFn1 = vi.fn();
    const wrapper = getTreeSelectDefaultMount(
      TreeSelect,
      { filterable: true, value: 1 },
      { focus: onFocusFn, blur: onBlurFn1 },
    );
    wrapper.find('.t-input').trigger('click');
    await mockDelay(100);
    expect(onFocusFn).toHaveBeenCalled();
    expect(onFocusFn.mock.calls[0][0].e.type).toBe('focus');
    expect(onFocusFn.mock.calls[0][0].value).toBe(1);
    simulateDocumentMouseEvent(document, 'mousedown');
    await new Promise(setTimeout);
    document.querySelectorAll('.t-popup').forEach((node) => node.remove());
    expect(onBlurFn1).toHaveBeenCalled();
    expect(onBlurFn1.mock.calls[0][0].e.type).toBe('mousedown');
    expect(onBlurFn1.mock.calls[0][0].value).toBe(1);
  });

  it('events.blur: multiple select blur works fine', async () => {
    const onFocusFn = vi.fn();
    const onBlurFn1 = vi.fn();
    const wrapper = getTreeSelectMultipleMount(
      TreeSelect,
      { filterable: true, value: [1] },
      { focus: onFocusFn, blur: onBlurFn1 },
    );
    wrapper.find('.t-input').trigger('click');
    await wrapper.vm.$nextTick();
    expect(onFocusFn).toHaveBeenCalled();
    expect(onFocusFn.mock.calls[0][0].e.type).toBe('focus');
    simulateDocumentMouseEvent(document, 'mousedown');
    await new Promise(setTimeout);
    document.querySelectorAll('.t-popup').forEach((node) => node.remove());
    expect(onBlurFn1).toHaveBeenCalled();
    expect(onBlurFn1.mock.calls[0][0].e.type).toBe('mousedown');
    expect(onBlurFn1.mock.calls[0][0].value).toEqual([1]);
  });

  it('events.change: Single TreeSelect, click one tree item to trigger value change', async () => {
    const onChangeFn1 = vi.fn();
    const wrapper = getTreeSelectDefaultMount(TreeSelect, { treeProps: { expandAll: true } }, { change: onChangeFn1 });
    wrapper.find('.t-input').trigger('click');
    await mockDelay(200);
    document.querySelector('.t-tree__item:nth-child(3)').click();
    await wrapper.vm.$nextTick();
    document.querySelectorAll('.t-popup').forEach((node) => node.remove());
    expect(onChangeFn1).toHaveBeenCalled();
    expect(onChangeFn1.mock.calls[0][0]).toBe('2.1');
    expect(onChangeFn1.mock.calls[0][1].e.type).toBe('click');
    expect(onChangeFn1.mock.calls[0][1].node.label).toBe('tdesign-web-react');
    expect(onChangeFn1.mock.calls[0][1].data).toEqual({ label: 'tdesign-web-react', value: '2.1' });
  });

  it('events.change: Multiple TreeSelect, click one tree item to trigger value change', async () => {
    const onChangeFn1 = vi.fn();
    const wrapper = getTreeSelectMultipleMount(TreeSelect, { treeProps: { expandAll: true } }, { change: onChangeFn1 });
    wrapper.find('.t-input').trigger('click');
    await mockDelay(200);
    document.querySelector('.t-tree__item:last-child .t-checkbox__label').click();
    await wrapper.vm.$nextTick();
    document.querySelectorAll('.t-popup').forEach((node) => node.remove());
    expect(onChangeFn1).toHaveBeenCalled();
    expect(onChangeFn1.mock.calls[0][0]).toEqual([1, '2.1', '2.2', 3, '4', '5', '6']);
    expect(onChangeFn1.mock.calls[0][1].trigger).toBe('check');
    expect(onChangeFn1.mock.calls[0][1].e.type).toBe('change');
    expect(onChangeFn1.mock.calls[0][1].node.label).toBe('tdesign-mobile-vue');
    expect(onChangeFn1.mock.calls[0][1].data).toEqual({ label: 'tdesign-mobile-vue', value: '6' });
  });

  it('events.change: Multiple TreeSelect, click one tree item to delete', async () => {
    const onChangeFn1 = vi.fn();
    const wrapper = getTreeSelectMultipleMount(TreeSelect, { treeProps: { expandAll: true } }, { change: onChangeFn1 });
    wrapper.find('.t-input').trigger('click');
    await mockDelay(200);
    document.querySelector('.t-tree__item:first-child .t-checkbox__label').click();
    await wrapper.vm.$nextTick();
    document.querySelectorAll('.t-popup').forEach((node) => node.remove());
    expect(onChangeFn1).toHaveBeenCalled();
    expect(onChangeFn1.mock.calls[0][0]).toEqual(['2.1', '2.2', 3, '4', '5']);
    expect(onChangeFn1.mock.calls[0][1].trigger).toBe('uncheck');
    expect(onChangeFn1.mock.calls[0][1].e.type).toBe('change');
    expect(onChangeFn1.mock.calls[0][1].node.label).toBe('tdesign-vue');
  });

  it('events.clear: Multiple TreeSelect, clear all value on click clear icon', async () => {
    const onClearFn1 = vi.fn();
    const onChangeFn1 = vi.fn();
    const onPopupVisibleChangeFn1 = vi.fn();
    const wrapper = getTreeSelectMultipleMount(
      TreeSelect,
      { clearable: true },
      { clear: onClearFn1, change: onChangeFn1, 'popup-visible-change': onPopupVisibleChangeFn1 },
    );
    wrapper.find('.t-input').trigger('mouseenter');
    await wrapper.vm.$nextTick();
    wrapper.find('.t-tag-input__suffix-clear').trigger('click');
    await wrapper.vm.$nextTick();
    document.querySelectorAll('.t-popup').forEach((node) => node.remove());
    expect(onClearFn1).toHaveBeenCalled();
    expect(onClearFn1.mock.calls[0][0].e.type).toBe('click');
    expect(onChangeFn1).toHaveBeenCalled();
    expect(onChangeFn1.mock.calls[0][0]).toEqual([]);
    expect(onChangeFn1.mock.calls[0][1].trigger).toBe('clear');
    expect(onPopupVisibleChangeFn1).toHaveBeenCalled();
    expect(onPopupVisibleChangeFn1.mock.calls[0][0]).toBe(false);
    expect(onPopupVisibleChangeFn1.mock.calls[0][1].trigger).toBe('clear');
  });

  it('events.clear: Single TreeSelect, clear value on click clear icon', async () => {
    const onClearFn1 = vi.fn();
    const onChangeFn1 = vi.fn();
    const onPopupVisibleChangeFn1 = vi.fn();
    const wrapper = getTreeSelectDefaultMount(
      TreeSelect,
      { value: 1, clearable: true },
      { clear: onClearFn1, change: onChangeFn1, 'popup-visible-change': onPopupVisibleChangeFn1 },
    );
    wrapper.find('.t-input').trigger('mouseenter');
    await wrapper.vm.$nextTick();
    wrapper.find('.t-input__suffix-clear').trigger('click');
    await wrapper.vm.$nextTick();
    document.querySelectorAll('.t-popup').forEach((node) => node.remove());
    expect(onClearFn1).toHaveBeenCalled();
    expect(onClearFn1.mock.calls[0][0].e.type).toBe('click');
    expect(onChangeFn1).toHaveBeenCalled();
    expect(onChangeFn1.mock.calls[0][0]).toBe(undefined);
    expect(onChangeFn1.mock.calls[0][1].trigger).toBe('clear');
    expect(onPopupVisibleChangeFn1).toHaveBeenCalled();
    expect(onPopupVisibleChangeFn1.mock.calls[0][0]).toBe(false);
    expect(onPopupVisibleChangeFn1.mock.calls[0][1].trigger).toBe('clear');
  });

  it('events.focus works fine', async () => {
    const onFocusFn = vi.fn();
    const wrapper = getTreeSelectMultipleMount(TreeSelect, { filterable: true, value: [1] }, { focus: onFocusFn });
    wrapper.find('input').trigger('focus');
    await wrapper.vm.$nextTick();
    document.querySelectorAll('.t-popup').forEach((node) => node.remove());
    expect(onFocusFn).toHaveBeenCalled();
    expect(onFocusFn.mock.calls[0][0].value).toEqual([1]);
    expect(onFocusFn.mock.calls[0][0].e.type).toBe('focus');
  });

  it('events.focus works fine', async () => {
    const onFocusFn = vi.fn();
    const wrapper = getTreeSelectMultipleMount(
      TreeSelect,
      { filterable: true, value: [{ label: 'tdesign-vue', value: 1 }] },
      { focus: onFocusFn },
    );
    wrapper.find('input').trigger('focus');
    await wrapper.vm.$nextTick();
    document.querySelectorAll('.t-popup').forEach((node) => node.remove());
    expect(onFocusFn).toHaveBeenCalled();
    expect(onFocusFn.mock.calls[0][0].value).toEqual([{ label: 'tdesign-vue', value: 1 }]);
    expect(onFocusFn.mock.calls[0][0].e.type).toBe('focus');
  });

  it('events.inputChange: clear filter words on change', async () => {
    const onInputChangeFn1 = vi.fn();
    const wrapper = getTreeSelectMultipleMount(
      TreeSelect,
      { inputValue: 'tdesign-vue' },
      { 'input-change': onInputChangeFn1 },
    );
    wrapper.find('.t-input').trigger('click');
    await mockDelay(200);
    document.querySelector('.t-tree__item:first-child .t-checkbox__label').click();
    await wrapper.vm.$nextTick();
    expect(onInputChangeFn1).toHaveBeenCalled();
    expect(onInputChangeFn1.mock.calls[0][0]).toBe('');
    expect(onInputChangeFn1.mock.calls[0][1].trigger).toBe('change');
  });

  it('events.popupVisibleChange works fine', async () => {
    const onPopupVisibleChangeFn = vi.fn();
    const wrapper = getTreeSelectMultipleMount(
      TreeSelect,
      { inputValue: 'tdesign' },
      { 'popup-visible-change': onPopupVisibleChangeFn },
    );
    wrapper.find('.t-input').trigger('click');
    await mockDelay(200);
    expect(onPopupVisibleChangeFn).toHaveBeenCalled();
    expect(onPopupVisibleChangeFn.mock.calls[0][0]).toBe(true);
  });

  it('events.remove: remove first value on click close icon', async () => {
    const onRemoveFn = vi.fn();
    const wrapper = getTreeSelectMultipleMount(TreeSelect, {}, { remove: onRemoveFn });
    wrapper.find('.t-tag__icon-close').trigger('click');
    await wrapper.vm.$nextTick();
    expect(onRemoveFn).toHaveBeenCalled();
    expect(onRemoveFn.mock.calls[0][0].value).toBe(1);
    expect(onRemoveFn.mock.calls[0][0].index).toBe(0);
    expect(onRemoveFn.mock.calls[0][0].trigger).toBe('tag-remove');
    expect(onRemoveFn.mock.calls[0][0].data).toEqual({ label: 'tdesign-vue', value: 1 });
    expect(onRemoveFn.mock.calls[0][0].e.type).toBe('click');
  });

  it('events.remove: remove last child on keydown.backspace', async () => {
    const onRemoveFn1 = vi.fn();
    const wrapper = getTreeSelectMultipleMount(TreeSelect, { filterable: true }, { remove: onRemoveFn1 });
    wrapper.find('.t-input').trigger('click');
    await wrapper.vm.$nextTick();
    wrapper.find('input').trigger('keydown.backspace');
    await wrapper.vm.$nextTick();
    expect(onRemoveFn1).toHaveBeenCalled();
    expect(onRemoveFn1.mock.calls[0][0].value).toBe('5');
    expect(onRemoveFn1.mock.calls[0][0].index).toBe(4);
    expect(onRemoveFn1.mock.calls[0][0].trigger).toBe('backspace');
    expect(onRemoveFn1.mock.calls[0][0].data).toEqual({ label: 'tdesign-angular', value: '5' });
    expect(onRemoveFn1.mock.calls[0][0].e.type).toBe('keydown');
  });

  it('events.search: Single TreeSelect, trigger search event on input text', async () => {
    const onSearchFn1 = vi.fn();
    const wrapper = getTreeSelectDefaultMount(TreeSelect, { filterable: true }, { search: onSearchFn1 });
    wrapper.find('.t-input').trigger('click');
    await wrapper.vm.$nextTick();
    const inputDom1 = wrapper.find('input').element;
    simulateInputChange(inputDom1, 'tdesign-vue');
    await wrapper.vm.$nextTick();
    expect(onSearchFn1).toHaveBeenCalled();
    expect(onSearchFn1.mock.calls[0][0]).toBe('tdesign-vue');
  });

  it('events.search: Single TreeSelect, trigger search event on input enter', async () => {
    const onSearchFn2 = vi.fn();
    const wrapper = getTreeSelectDefaultMount(TreeSelect, { filterable: true }, { search: onSearchFn2 });
    wrapper.find('.t-input').trigger('click');
    await wrapper.vm.$nextTick();
    const inputDom1 = wrapper.find('input').element;
    simulateInputChange(inputDom1, 'tdesign-vue');
    await wrapper.vm.$nextTick();
    const inputDom2 = wrapper.find('input').element;
    simulateInputEnter(inputDom2);
    await wrapper.vm.$nextTick();
    expect(onSearchFn2).toHaveBeenCalled();
    expect(onSearchFn2.mock.calls[1][0]).toBe('tdesign-vue');
  });

  it('events.search: Multiple TreeSelect, trigger search event on input text', async () => {
    const onSearchFn1 = vi.fn();
    const wrapper = getTreeSelectMultipleMount(TreeSelect, { filterable: true }, { search: onSearchFn1 });
    wrapper.find('.t-input').trigger('click');
    await wrapper.vm.$nextTick();
    const inputDom1 = wrapper.find('input').element;
    simulateInputChange(inputDom1, 'tdesign-vue');
    await wrapper.vm.$nextTick();
    expect(onSearchFn1).toHaveBeenCalled();
    expect(onSearchFn1.mock.calls[0][0]).toBe('tdesign-vue');
  });

  it('events.search: Multiple TreeSelect, trigger search event on input enter', async () => {
    const onSearchFn2 = vi.fn();
    const wrapper = getTreeSelectMultipleMount(TreeSelect, { filterable: true }, { search: onSearchFn2 });
    wrapper.find('.t-input').trigger('click');
    await wrapper.vm.$nextTick();
    const inputDom1 = wrapper.find('input').element;
    simulateInputChange(inputDom1, 'tdesign-vue');
    await wrapper.vm.$nextTick();
    const inputDom2 = wrapper.find('input').element;
    simulateInputEnter(inputDom2);
    await wrapper.vm.$nextTick();
    expect(onSearchFn2).toHaveBeenCalled();
    expect(onSearchFn2.mock.calls[1][0]).toBe('tdesign-vue');
  });
});
